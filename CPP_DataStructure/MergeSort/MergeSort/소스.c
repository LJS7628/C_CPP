/*
합병정렬(Merge Sort)
	어느 상황에서도 n log n 의 시간 복잡도를 가지는 정렬
	퀵정렬에서 n^2 의 시간 복잡도가 나올 수 있는 이유는
		최악의 경우엔 2개로 나눌 수 없는 상황이 반복

	합병정렬은 무조건 2개로 나눔
	조건 없이, 배열의 길이에 따라서 2부분으로 나눔
	이후 배열들을 하나로 합쳐가며 정렬

	시간 복잡도 O(n log n)
		최악의 경우에도 동일

	data : 1	5	4	9	0	7
		   1	5	4  /9	0	7
		   1	5/	4        9	0/	7
		   1 / 5 / 4		9 / 0 / 7
		   --------------------------
		   1  5/ 4			0 9 /7
		   --------------------------
		   1  4  5			0 7 9
		   -------------------------
		   0 1 4 5 7 9

과정
	1. 배열을 2개로 나눔 (더이상 나눠지지 않을때 까지 0,1개)
	2. 나누는 과정이 다 끝나면, 마지막에 나눠진 배열부터 나눠진 순서의 역순으로 합침
		->재귀

합치는 과정
	1. 두 배열의 각각 가장 앞에 커서를 위치하고 시작
	2. 두 커서가 가르키는 값들 중, 더 작은 값을 임시 배열에 저장
	3. 저장된 값을 가르키던 커서는 뒤로 한칸 이동
	4. 2번을 한쪽 커서가 범위를 벗어나기 전 까지 반복
	5. 범위를 벗어나지 않은 쪽 배열의 나머지 값을 임시배열에 순차적으로 저장
	6. 임시 배열에 저장된 정렬된 배열을 원본 배열에 복사

연습
		7 5 2 6 9 10 0 1 15 20
*/
#include <stdio.h>
#include <stdlib.h>
#include "util.h"
#include "merge_sort.h"


int main() {
	int data[] = { 7,5,2,6,9,10,0,1,15,20 };
	int size = sizeof(data) / sizeof(int);

	int* sorted;
	sorted = merge_sort(data, size);
	print_list(sorted, size);

	print_list(data, size);
}

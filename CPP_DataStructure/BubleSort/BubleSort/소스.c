/*
버블 정렬(Bubble sort)
	작은 값이 하나씪 위로 떠오르는 모양으로 정렬
	순서대로 두개의 값이 비교해서, 더 작은값을 앞으로 위치

	0. 배열의 갯수만큼 반복
	1. 처음부터 끝(-횟수)까지 반복
	2. 현재값과 다음값을 비교
	3. 다음값이 더 작다면, 두 값의 위치를 변경

	시간 복잡도 : O(n^2)
*/

/*
퀵 정렬(Quick sort)
	
최상: 시간 복잡도 : O(n*log n)
최악: 시간 복잡도 : O(n^2)

	가장 앞에 있는 수를 선택
	선택된 수 보다 작은 값은 왼쪽에
	선택된 수 보다 큰 값은 오른쪽에 모음

	이것을 반복하면, 어떤 숫자를 선택해도
	선택된 수 보다 오른쪽에는 큰 수만
	모여있게 됨
	즉, 정렬된 상태가 됨

	만약, 선탣괸 수가, 가장 큰 수거나 가장 작은수면
	두 부분으로 나눠지지 않기 때문에 
	n*n의 시간복잡도를 가지게 됨
	(이미 정렬되어있는 경우가 대표적)

실제 구현
	구현 1.
		선택 되는 수는 분할된 배열 중 가장 앞

	구현 2.
		왼쪽부터 오른족으로 이동하는 커서와
		오른쪽부터 왼쪽으로 이동하는 커서를
		하나씩 두고

		왼쪽 커서는 왼쪽에 와도 되는 수 인지 검사
		(즉 선택된 값 보다 작은지 검사)
		오른쪽 커서는 오른쪽에 있어도 되는 검사
		(즉 선택된 값 보다 큰지 검사)

	구현 3.
		1,2 등 작업을 마치고 나면 2개로 분활
		각 분할별로 별도로 같은 작업을 수행
		이를 위해 재귀함수로 사용


	연습 (손과 노트로 해보세요)
		7 5 2 6 9 10 0 1 15 20
*/

#include <stdio.h>
#include <stdlib.h>
#include "util.h"
#include "bub_sort.h"

int main() {
	int data[] = { 1,5,4,9,0,7 };
	int size = sizeof(data) / sizeof(int);

	int* sorted;
	sorted = bub_sort(data, size);

	print_list(data,size);
	print_list(sorted, size);
}

